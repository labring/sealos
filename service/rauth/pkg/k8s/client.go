package k8s

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

const (
	// DefaultSecretName is the fixed secret name generated by controller in each namespace
	DefaultSecretName = "devbox-registry"
)

// ClientInterface defines the interface for Kubernetes client operations
type ClientInterface interface {
	GetNamespaceCredentials(ctx context.Context, namespace string) (*RegistryCredentials, error)
	NamespaceExists(ctx context.Context, namespace string) (bool, error)
}

// RegistryCredentials holds the username and password for registry authentication
type RegistryCredentials struct {
	Username string
	Password string
}

// Client wraps kubernetes clientset
type Client struct {
	clientset    kubernetes.Interface
	secretName   string
	registryHost string // registry host for dockerconfigjson lookup
}

// NewClient creates a new kubernetes client
func NewClient(secretName, registryHost string) (*Client, error) {
	var (
		config *rest.Config
		err    error
	)

	// Try in-cluster config first
	config, err = rest.InClusterConfig()
	if err != nil {
		// Fall back to kubeconfig for local development
		kubeconfig := os.Getenv("KUBECONFIG")
		if kubeconfig == "" {
			kubeconfig = os.Getenv("HOME") + "/.kube/config"
		}

		config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
		if err != nil {
			return nil, fmt.Errorf("failed to create kubernetes config: %w", err)
		}
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, fmt.Errorf("failed to create kubernetes clientset: %w", err)
	}

	if secretName == "" {
		secretName = DefaultSecretName
	}

	return &Client{
		clientset:    clientset,
		secretName:   secretName,
		registryHost: registryHost,
	}, nil
}

// NewClientWithInterface creates a client with a provided kubernetes interface (for testing)
func NewClientWithInterface(
	clientset kubernetes.Interface,
	secretName, registryHost string,
) *Client {
	if secretName == "" {
		secretName = DefaultSecretName
	}

	return &Client{
		clientset:    clientset,
		secretName:   secretName,
		registryHost: registryHost,
	}
}

// GetNamespaceCredentials retrieves registry credentials from the secret in specified namespace
func (c *Client) GetNamespaceCredentials(
	ctx context.Context,
	namespace string,
) (*RegistryCredentials, error) {
	secret, err := c.clientset.CoreV1().
		Secrets(namespace).
		Get(ctx, c.secretName, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf(
			"failed to get secret %s in namespace %s: %w",
			c.secretName,
			namespace,
			err,
		)
	}

	return ExtractCredentials(secret, c.registryHost)
}

// GetRegistryHost returns the configured registry host
func (c *Client) GetRegistryHost() string {
	return c.registryHost
}

// DockerConfigJSON represents the structure of .dockerconfigjson
type DockerConfigJSON struct {
	Auths map[string]DockerConfigEntry `json:"auths"`
}

// DockerConfigEntry represents a single registry entry in dockerconfigjson
type DockerConfigEntry struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Auth     string `json:"auth"` // base64(username:password)
}

// ExtractCredentials extracts username and password from secret
// Supports both kubernetes.io/dockerconfigjson and Opaque secret types
// For dockerconfigjson, registryHost specifies which registry entry to use
func ExtractCredentials(secret *corev1.Secret, registryHost string) (*RegistryCredentials, error) {
	// Try kubernetes.io/dockerconfigjson format first
	if secret.Type == corev1.SecretTypeDockerConfigJson {
		return extractFromDockerConfigJSON(secret, registryHost)
	}

	// Fall back to Opaque secret with username/password keys
	return extractFromOpaqueSecret(secret)
}

// extractFromDockerConfigJSON extracts credentials from kubernetes.io/dockerconfigjson secret
// registryHost specifies which registry entry to look up (e.g., "internal-registry.io")
func extractFromDockerConfigJSON(
	secret *corev1.Secret,
	registryHost string,
) (*RegistryCredentials, error) {
	data, ok := secret.Data[corev1.DockerConfigJsonKey]
	if !ok {
		return nil, errors.New("secret does not contain '.dockerconfigjson' key")
	}

	var config DockerConfigJSON
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse .dockerconfigjson: %w", err)
	}

	if len(config.Auths) == 0 {
		return nil, errors.New(".dockerconfigjson contains no auth entries")
	}

	// Look up the specific registry host entry
	entry, ok := config.Auths[registryHost]
	if !ok {
		return nil, fmt.Errorf("registry host %q not found in .dockerconfigjson", registryHost)
	}

	// Try username/password fields first
	if entry.Username != "" && entry.Password != "" {
		return &RegistryCredentials{
			Username: entry.Username,
			Password: entry.Password,
		}, nil
	}

	// Fall back to decoding auth field (base64 of "username:password")
	if entry.Auth != "" {
		decoded, err := base64.StdEncoding.DecodeString(entry.Auth)
		if err != nil {
			return nil, fmt.Errorf("failed to decode auth field: %w", err)
		}

		parts := strings.SplitN(string(decoded), ":", 2)
		if len(parts) != 2 {
			return nil, errors.New("invalid auth field format, expected 'username:password'")
		}

		return &RegistryCredentials{
			Username: parts[0],
			Password: parts[1],
		}, nil
	}

	return nil, fmt.Errorf("no valid credentials found for registry host %q", registryHost)
}

// extractFromOpaqueSecret extracts credentials from Opaque secret with username/password keys
func extractFromOpaqueSecret(secret *corev1.Secret) (*RegistryCredentials, error) {
	username, ok := secret.Data["username"]
	if !ok {
		return nil, errors.New("secret does not contain 'username' key")
	}

	password, ok := secret.Data["password"]
	if !ok {
		return nil, errors.New("secret does not contain 'password' key")
	}

	return &RegistryCredentials{
		Username: string(username),
		Password: string(password),
	}, nil
}

// NamespaceExists checks if a namespace exists
func (c *Client) NamespaceExists(ctx context.Context, namespace string) (bool, error) {
	_, err := c.clientset.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
	if err != nil {
		return false, nil
	}

	return true, nil
}

// GetSecretName returns the configured secret name
func (c *Client) GetSecretName() string {
	return c.secretName
}
